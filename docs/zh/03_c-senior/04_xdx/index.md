# 第一章：回顾虚拟地址空间

## 1.1 概述

* 在学习 C 语言中的过程中，我们可以通过 `&` 运算符来获取变量的内存地址，如下所示：

 ```c
 #include <stdio.h>
 
 // 全局变量
 int a = 10;
 int b = 20;
 
 int main() {
 
     // 禁用 stdout 缓冲区
     setbuf(stdout, nullptr);
 
     printf("a = %p\n", &a); // a = 0x55fda7351010
     printf("b = %p\n", &b); // b = 0x55fda7351014
 
     return 0;
 }
 ```

* 我们也知道，现代操作系统是`多用户`、`多任务`、`图形化`、`网络化`的操作系统。其中，所谓的`多任务`就是可以支持多个应用程序（进程），如下所示：

![](./assets/1.png)

> [!NOTE]
>
> - ① 正如上面的程序一样，程序在链接的时候，内存地址就已经确定了，无法改变。
> - ② 如果此时，物理内存中的内存地址已经被该程序占用了，那么其它程序岂不是运行不了？
> - ③ 如果此时，物理内存中的内存地址已经被其它程序占用了，那么该程序岂不是运行不了？

* 其实，这些地址都是假的，并不是真实的物理地址，而是虚拟地址（虚地址）。虚拟地址（虚地址）需要通过 CPU 内部的 MMU（Memory Management Unit，内存管理单元）来将这些虚拟地址（虚地址）转换为物理地址（实地址），如下所示：

![](./assets/2.svg)

## 1.2 虚拟地址空间模型

* 为了更好的管理程序，操作系统将虚拟地址空间分为了不同的内存区域，这些内存区域存放的数据、用途、特点等皆有不同，下面是 Linux 下 32 位环境的经典内存模型，如下所示：

![](./assets/3.svg)

- 每个内存区域的特点，如下所示：

| 内存分区                  | 说明                                                         |
| :------------------------ | :----------------------------------------------------------- |
| 程序代码区（code）        | 存储程序的执行代码，通常为只读区，包含程序的指令。 程序启动时，这部分内存被加载到内存中，并不会在程序执行期间改变。 |
| 常量区（constant）        | 存放程序中定义的常量值，通常也是只读的，这些常量在程序运行期间不可修改。 |
| 全局数据区（global data） | 存储程序中定义的全局变量和静态变量。 这些变量在程序的整个生命周期内存在，且可以被修改。 |
| 堆区（heap）              | 用于动态分配内存，例如：通过 `malloc` 或 `new` 分配的内存块。 堆区的内存由程序员手动管理，负责分配和释放。 如果程序员不释放，程序运行结束时由操作系统回收。 |
| 动态链接库                | 动态链接库（如： `.dll` 或 `.so` 文件）被加载到内存中特定的区域，供程序运行时使用。 |
| 栈区（stack）             | 用于存储函数调用的局部变量、函数参数和返回地址。 栈是自动管理的，随着函数的调用和返回，栈上的内存会自动分配和释放。 |

> [!NOTE]
>
> - ① 程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。
> - ② 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。
> - ③ 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

* 在 64 位 Linux 环境下，虚拟地址空间大小为 256TB，Linux 将高 128TB 的空间分配给内核使用，而将低 128TB 的空间分配给用户程序使用，如下所示：

![](./assets/4.svg)

> [!NOTE]
>
> - ① `程序代码区`，也可以称为`代码段`；而`全局数据区`和`常量区`，也可以称为`数据段`。
> - ② `全局数据区`分为`初始化数据段`（存储已初始化的全局变量和静态变量）和`未初始化数据段`（存储未初始化的全局变量和静态变量）；`常量区`也称为`只读数据段`，通常是只读的，防止数据被修改。
> - ③ 冯·诺依曼体系结构中的`程序`，也被称为`存储式程序`，需要通过加载器（Loader），将程序从硬盘加载到内存中运行。
> - ④ `存储式程序`中的`程序`分为`指令`和`数据`；其中，`代码段`中保存的是`指令`，`数据段`中保存的是`数据`。



# 第二章：C 语言中的字符串和字符数组（⭐）

## 2.1 概述

* 在实际开发中，我们除了经常处理整数、浮点数、字符、数组等，还需要经常和`字符串`打交道，如：`"Hello World"`、`"Hi"` 等。

## 2.2 字符串和字符数组

* 和其他编程语言（如：Java 中的 String、TS 中的 string 等）不同，C 语言其实是没有专门的`字符串类型`的。
* 在 C 语言中，`字符串`是通过`字符数组`来进行存储的，以空字符 `\0` 作为结尾，这样的字符串也被称为 `C 风格的字符串`。

* 假设 C 程序中的字符串是 `"Hello World!"`，如下所示：

```c
"Hello World!" // 在 C 语言中，底层存储就是 Hello World!\0
```

* 其底层就是这样存储的，如下所示：

![](./assets/5.png)

## 2.3 字符串和字符数组的区别

* `在 C 语言中，字符串就是字符数组；但是，字符数组却不一定是字符串。`
* 对于 `“Hello”` 这样的字符串，我们可以这些定义，如下所示：

```c
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

* 在 C 语言中，如果没有给出数组中元素的个数，却给出了初始化的元素，将由系统自动推断出数组中元素的个数，如下所示：

```c
char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

* 但是，上述的写法实在太繁琐，C 语言给我们提供了语法糖，如下所示：

```c
char str[] = "Hello";
```

> [!CAUTION]
>
> * ① `语法糖`是编程语言中的一种术语，指的是一些让程序更加简洁易懂、表达更直观的语法特性。它们不会增加语言的功能或表达能力，而是提供更方便或更易读的方式来实现某些操作。可以理解为，它是一种编程语言设计上的便利，它使得写代码时的语法更加简洁、易懂，但本质上与原本的功能没有区别。
> * ② 对于`char str[] = "Hello";`，其底层存储的依然是`'H'`、`'e'`、`'l'`、`'l'` 、`'o'`、`'\0'`。

* 如果我们将 `'\0'` 放在中间，如：`"He\0llo"`，就不再表示 `"Hello"`，而是表示 `"He"`，如下所示：

```c
char str[] = "He\0llo"; // He
```

```c
char str[] = {'H', 'e','\0', 'l', 'l', 'o', '\0'}; // He
```

## 2.4 打印字符串

* 在 C 语言中，可以通过 `printf` 函数来打印字符串，并通过格式占位符 `%s` 来代表字符串。

> [!CAUTION]
>
> * ① `%s`会忽略字符串前面的空白字符，并一直匹配到空字符`'\0'`为止。
> * ② 如果一直没有`'\0'`，就会越界访问，直到访问到`'\0'`为止，即：会产生野指针。



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

    // str = Hello
    printf("str = %s\n", str); // [!code highlight]

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};

    // str = Hello
    printf("str = %s\n", str); // [!code highlight]

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = "Hello";

    // str = Hello
    printf("str = %s\n", str); // [!code highlight]

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = {'H', 'e','\0', 'l', 'l', 'o', '\0'};

    // str = He
    printf("str = %s\n", str); // [!code highlight]

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = "He\0llo";

    // str = He
    printf("str = %s\n", str); // [!code highlight]

    return 0;
}
```

## 2.5 C 语言中字符串设计的优缺点以及产生的影响

### 2.5.1 概述

* 优点：
  * ① **简单高效**：字符串通过`'\0'`结尾，处理简单，且C库提供了基础的字符串函数。
  * ② **性能好**：不需要一个额外的新类型、内存占用较少（和其他语言中的字符串对比）。
  * ③ **灵活性强**：可以直接操作字符数组，甚至用指针高效传递。
  * ④ **内存高效**：字符串是字符数组，内存管理由程序员控制，节省空间。
* 缺点：
  * ① **无法直接判断字符串**：C 语言中的字符串是以`'\0'`（空字符）作为结束符的，因此无法直接判断一个字符数组是否是字符串，必须遍历数组直到找到`'\0'`。
  * ② **操作繁琐**：处理字符串时需要手动管理`'\0'`字符，考虑到结束符的存在，很多字符串操作（如复制、拼接、比较）都变得复杂且容易出错。
  * ③ **字符串没有内建长度信息**：C 语言的字符串依赖`'\0'`作为结束标志，而没有像其他语言那样的长度属性。没有`'\0'`就无法正确处理字符串。
  * ④ **获取字符串长度消耗性能**：C语言获取字符串长度必须遍历整个字符串，直到遇到`'\0'`，对于长字符串来说，效率较低。

> [!IMPORTANT]
>
> 鉴于以上的缺点，在 C 语言之后的许多编程语言，如：C++、Java、Go 等都内置了单独的 string 类型，并且这些单独的 string 类型自带数组长度的属性。

### 2.5.2 大小（size）和容量（capacity）

* `大小（size）`：表示容器中当前存储的元素的数量，例如：
  * 对于一个数组，大小就是数组中实际存储的元素个数。
  * 对于一个字符串，大小是字符串的长度，不包括结束符（`'\0'`）。
  * 对于容器类（`std::vector`或`std::string`），`size`通常表示已使用的元素个数。

```c
// 字符串 "hello"，容量（capacity）是 6，大小（size）是 5（不包括'\0'）
char str[] = "hello";  
```



![](./assets/6.png)

* `容量（capacity）`：表示容器可以存储的最大元素数量。在很多动态数据结构中，容量可能大于当前大小，因为容器通常会预分配一定的内存空间以便应对未来的增长，例如：
  * 对于动态数组（`std::vector`或`std::string`），容量是指该数组当前能够容纳的元素个数，通常是实现的一个优化，避免每次增加元素时都进行内存重新分配。
  * 对于固定大小的容器（C 语言中的数组），容量就是数组的固定大小。

```c
// 字符串"hello"，容量（capacity）是 10，大小（size）是 5
char str[10] = "hello";  
```

![](./assets/7.png)

### 2.5.3 C 语言之后的编程语言是如何设计字符串的？

* C 语言之后的编程语言（C++、Java 等）设计的字符串，类似于 C 语言中的结构体，如下所示：

![](./assets/8.svg)



# 第三章：字符串字面值（⭐）

## 3.1 概述

* C 语言是支持在代码中直接书写`字面量`的，如： 整数字面量、浮点数字面量、字符字面量以及字符串字面量。

> [!NOTE]
>
> 字面量（字面量常量）：就是可以直接使用的常量，而不需要声明或定义。



* 示例：

```c
#include <stdio.h>

int main() {

     // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);
    
    1;  // 整数字面量
    'A'; // 字符字面量
    12.3; // 浮点数字面量
    "你好"; // 字符串字面量

    return 0;
}
```

## 3.2 字符串字面量

* 在 C 语言中，当我们在源码中直接使用双引号括起来的字符序列，如：`"Hello World"`等，就称为`字符串字面量`（字符串字面量常量），它们是程序中的常量值。

* 在 C 语言中，字符串字面值的表示形式比较灵活，有如下的几种形式：

  * ① **`标准字符串字面值`**（常用）：普通的字符串字面值使用双引号包裹，默认以 `\0` 作为结束标志；这种形式是最常见的，字符串由 ASCII 或 UTF-8 字符组成。

  ```c
  char str[] = "Hello World!";
  ```

  * ② **多行字符串字面值**：多行中用反斜杠`\`实现换行。

  ```c
  char str[] = "This is a long string\n \
  that spans multiple lines."; // 使用反斜杠换行
  ```

  * ③ **多行字符串字面值**：可以通过使用多个双引号直接拼接。

  ```c
  char str[] = "Hello" "World";
  ```

> [!NOTE]
>
> printf 函数中的 `%s` 格式占位符，也支持上述字符串的写法！！！



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = "Hello World!";
    
    printf("str: %s\n", str);

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = "This is a long string\n \
that spans multiple lines."; // 使用反斜杠换行

    printf("str: %s\n", str);

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    char str[] = "Hello"
                 " World!";
    printf("str: %s\n", str);

    return 0;
}
```

## 3.3 字符串字面值的存储形式

### 3.3.1 概述

* 在 C 语言中，`字符串字面值`是以字符数组的形式存储的。`对于长度为 n 的字符串字面量，它是存储在虚拟地址空间中的只读数据段中，分配 n+1 长度的字符数组，用来存储字符序列以及一个空字符 \0 作为结尾`。
* `字符串字面值`在虚拟地址空间中的位置，如下所示：

![](./assets/9.svg)

* 如果一个字符串字面量是 `"abc"`，那么它在`只读数据段`中就是这么存储的，如下所示：

![](./assets/10.svg)

* 当然，字符串字面量也可以是一个空字符串 `""`，其在`只读数据段`就是这么存储的，如下所示：

![](./assets/11.svg)

* 字符串字面量存储在只读数据段，这就意味着字符串字面量有以下的特点：
  * ① 不可变、只读。
  * ② 静态存储期限，即：其生命周期和进程的生命周期相同。

> [!CAUTION]
>
> * ① 字符串字面量本质上就是一个存储在只读数据段中的字符数组。
> * ② 在 C 语言中，所有的字符串都是以一个空字符 `\0` 作为结尾的字符数组；但是，并非所有的字符数组都是字符串。

### 3.3.2 应用场景

* 字符串字面量在大多数情况下，都视为一个字符数组的数组名去使用，即：视为字符数组的首元素的指针。
* 但是，对于 sizeof 和 & 取地址符而言，就不能视为首元素的指针。

> [!NOTE]
>
> 这其实和《数组到底在什么时候会转换为指针》中讲解的原理是一样的。



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    // 指针 p 指向数据段中的只读字符串字面值数组，此时指针 p 无法修改指向内容
    char *p = "hello";

    char h = p[0];

    printf("%c\n",h); // h 

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    // "hello" 视为数组名，就意味着支持索引操作
    char c = "hello"[4];
    printf("%c\n", c); // o

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    // "hello" 视为数组名，视为指向数组首元素的指针
    char *c = "hello" + 4; // 和 Java 不同，在 Java 中是拼接；但是，C 语言中不是
    printf("%c\n", *c); // o

    return 0;
}
```



* 示例：

```c
#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    // "hello" 视为数组名，视为指向数组首元素的指针
    // 索引运算就是算术运算和解引用运算的语法糖。
    char c = *("hello" + 4);
    printf("%c\n", c); // o

    return 0;
}
```

## 3.4 字符串字面值的操作

### 3.4.1 概述

* 当`字符串字面量`在代码中视为`数组名`的时候，我们可以将其视为一个`字符常量数组`的`名字`，如：`const char str[]`。
* 这意味着`字符串字面量`有如下的特点：
  * ① `字符串字面量不能指向一个新的字符数组`：数组名视为指针的时候就是一个不可改变指向的指针，该指针指向数组首元素的地址，不可更改。
  * ② `字符串字面量指向的内容不可以修改`：字符串字面值存储在只读数据段中，具有只读性，所以内容也不可变。字符串字面值存储在只读数据段中，具有只读性，所以内容也不可变。

```c
// 错误，字符串字面量不能指向一个新的字符数组
"hello" = NULL; // [!code error]
```

```c
// 错误，字符串字面量指向的内容不可以修改
"hello"[4] = 'A' // [!code error]
```

* 既然`字符串字面量`可以视为数组名，即：视为字符数组的首元素的指针，那么将有以下的应用场景：
  * ① 使用`指针变量`接收`字符串字面量`。
  * ② 将`字符串字面量`作为`参数`进行传递。

### 3.4.2 使用指针变量接收字符串字面量

* 使用`指针变量`接收字符串字面量的时候，该指针是一个`指向常量`的指针，即：`指针可以改变指向；但是，指针指向的内容不可变`。

> [!NOTE]
>
> ::: details 点我查看 指针变量可变，但是指针指向的内容不可变
>
> * ① 指针变量可变。
>
> ```c
> #include <stdio.h>
> 
> int main() {
> 
>     // 禁用 stdout 缓冲区
>     setbuf(stdout, NULL);
> 
>     const char *p = "hello";
> 
>     // 指针 p 允许改变指向
>     p = "world"; // [!code highlight]
> 
>     printf("%s\n", p); // world
> 
>     return 0;
> }
> ```
>
> * ② 指针指向的内容不可变。
>
> ```c
> #include <stdio.h>
> 
> int main() {
> 
>     // 禁用 stdout 缓冲区
>     setbuf(stdout, NULL);
> 
>     const char *p = "hello";
> 
>     // 错误，指针 p 指向的内容不可变
>     *p = "h"; // [!code error]
> 
>     printf("%s\n", p); // world
> 
>     return 0;
> }
> ```
>
> :::



* 示例：

```c
![12](./C:/Users/Administrator/Desktop/12.svg)#include <stdio.h>

int main() {

    // 禁用 stdout 缓冲区
    setbuf(stdout, NULL);

    const char *p = "hello";

    printf("%s\n", p); // hello

    return 0;
}
```

### 3.4.3 将字符串字面量作为参数进行传递

* 我们经常会在 `printf` 或 `scanf` 中使用`字符串字面量`作为参数，即：

```c
printf("a + b = %d",a + b);
```

* 此时的字符串字面量 `"a + b = %d"`是在`只读数据段`中存储的一个`字符数组`，而传递给 `printf` 函数的就是该字符数组的首元素指针，如下所示：

![](./assets/12.svg)

> [!NOTE]
>
> 对于`字符串字面量`而言，即使函数内部得到了`字符串字面量`对应的`字符数组`的`首元素指针`，由于`字符串字面量`存储在`只读数据段`中，在函数内部是不能修改字符串内容的；否则，将会引发未定义行为。

* 如果函数中的参数可能传入`字符串字面量`，在声明的时候，请为`形参`添加 `const` 关键字，以明确其不可修改的特点，如下所示：

```c
int printf (const char *__format, ...);
```

```c
int scanf(const char *__format, ...);
```

```c
char *strcpy(char *dest, const char *src);
```

```c
char *strncpy( char *dest, const char *src, size_t count );
```

```c
char *strcat( char *dest, const char *src );
```

```c
char *strncat( char *dest, const char *src, size_t count );
```

```c
int strcmp( const char* lhs, const char* rhs );
```



# 第四章：字符串变量（⭐）

## 4.1 概述







# 第五章：标准字符串函数（⭐）

## 5.1 概述







# 第六章：字符串数组（⭐）

## 6.1 字符二维数组





## 6.2 字符指针数组





## 6.3 命令行参数
